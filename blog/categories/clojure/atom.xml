<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Paulo Suzart Blog]]></title>
  <link href="http://paulosuzart.github.com/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://paulosuzart.github.com/"/>
  <updated>2013-09-20T22:08:22-03:00</updated>
  <id>http://paulosuzart.github.com/</id>
  <author>
    <name><![CDATA[Paulo Suzart]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Geocoding CSVs with Clojure]]></title>
    <link href="http://paulosuzart.github.com/blog/2013/08/26/geocoding-csvs-with-clojure/"/>
    <updated>2013-08-26T11:48:00-03:00</updated>
    <id>http://paulosuzart.github.com/blog/2013/08/26/geocoding-csvs-with-clojure</id>
    <content type="html"><![CDATA[<p>Hi! Nothing like delivering some value to your company using your preferred tool, hun?</p>

<p>Well, I had this feeling after freeing up my team of writing and writing the same thing again and again. As you can seen at <a href="https://github.com/paulosuzart/ultimate-geo">ultimate-geo project page</a>:</p>

<blockquote><p>Ultimate Geo is the final definitive geocoding app. The motivation behind it was: We have different CSVs full of address in the most crazy combinations. Some of them has the street, number, site, phone. while others have same columns in a different order, etc. This led us to keep creating (actually adjusting) our geocode scripts. Now it is over.</p></blockquote>

<p>Of course it may not fit everyone's needs. But helped my scenario a lot.</p>

<p>After atending the <a href="http://www.meetup.com/clj-sp/events/132201232/">(sp (first meetup))</a> I polished this small project called <a href="https://github.com/paulosuzart/ultimate-geo"><code>ultimate-geo</code></a>, given I mentioned it while talking to people.</p>

<p>A general explannation of how <code>ultimate-geo</code> works can be found on its project page, but by didactic reasons, here a more detailed explanation:</p>

<ol>
<li>after parsing each line of a file</li>
<li>it binding each colum to named variables, so they can be latter referenced fo querying google and also for output. Works like in a prepared statement</li>
<li>then replaces <code>-query</code> parameter replacing named variables like <code>:country</code> or <code>:city</code> by their values mapped on step 2.</li>
<li>finally request google address information</li>
<li>and start generating results. Here few tricks are needed because goole can send back more than one results. So it filters the relevat result and pick the first one. From the same result it grabs the zip, if available.</li>
</ol>


<p>The image bellow depicts the flow of columns through this process:</p>

<p><img src="http://github.com/paulosuzart/ultimate-geo/raw/master/ultimate.png" alt="ultimate-geo" /></p>

<p>All happens lazily. So the code will not parse every single line, and then map all lines, and replace all values, etc. It happens as it goes. The main point to pay attention to is the write phase. This can pop up any exception during the process because it is the point that actually call all the chained lazy values.</p>

<p>Another important piece is <a href="http://clojuredocs.org/clojure_core/clojure.core/pmap"><code>pmap</code></a> for steps 2, 3 and 4. It means the all he lines are processed in parallel for eatch step increasing the overall performance.</p>

<p>Coding variable replacement was by far the funniest part. Check the <a href="https://github.com/paulosuzart/ultimate-geo/blob/master/test/geocoder/t_core.clj">project tests</a> and see how useful for other scenarios it can be:</p>

<p><div><script src='https://gist.github.com/6342437.js?file='></script>
<noscript><pre><code></code></pre></noscript></div>
</p>

<p>This works fine and is able to ignore <code>_</code> mapped columns, meaning they are not relevant and will not be used later.</p>

<p>The tests were written using <a href="https://github.com/marick/Midje">Midje</a>. I like Midje and it helped a lot to refactor the code while writing it specially using <code>:autotest</code>. I do recommend a try even if you want to use the basics, like I did.</p>

<p>This project uses other nice libs like <a href="https://github.com/davidsantiago/clojure-csv">clojure-csv</a> and <a href="https://github.com/clojure/tools.cli">clojure/toosl.cli</a> that can be presented later.</p>

<p>Hope you liked the post. After the meetup I intend to post more often and focus on what were discussed during the meetings.</p>

<p><p>Don't forget to visit the <a href="/about">about</a> page. And follow me on Twitter: <a href="http://twitter.com/paulosuzart">@paulosuzart</a>.</p>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Configuring Clojure Immutant by environment]]></title>
    <link href="http://paulosuzart.github.com/blog/2013/02/07/configuring-clojure-immutant-by-environment/"/>
    <updated>2013-02-07T08:39:00-02:00</updated>
    <id>http://paulosuzart.github.com/blog/2013/02/07/configuring-clojure-immutant-by-environment</id>
    <content type="html"><![CDATA[<p>Hi again! Not posting for too much long.</p>

<p>Well, this time we will explore the <a href="http://clojure.org">clojure's</a> ability to <a href="http://clojuredocs.org/clojure_core/clojure.core/load-file">load arbitrary files as code</a>.</p>

<p>This is such an amazing feature, but you should be careful. Don't start reading anyones files and evaluating them into your app. Be wise and use it for specific situation like this: I wanted to load a bunch of configurations (and even funtion calls) depending on the environment my app is running.</p>

<p>To do the conditional evaluation, I decided to add an extra key to <code>:immutant</code> entry in my project definition. The entry <code>:env</code> is an <a href="http://immutant.org/documentation/current/initialization.html#sec-3-1">arbitrary configuration value</a>. Lets take a look:</p>

<p>``` clojure Silly Project
(defproject tserver "0.1.0-SNAPSHOT"
  :description "A foo project"
  :url "http://foo.com/"
  :license {:name "Eclipse Public License"</p>

<pre><code>        :url "http://www.eclipse.org/legal/epl-v10.html"}
</code></pre>

<p>  :dependencies [[org.clojure/clojure "1.4.0"]</p>

<pre><code>             [compojure "1.0.2"]
             ;... and many other dependecies
</code></pre>

<p>  :jvm-opts ["-Xmx2g" "-server"]
  :immutant {:init "tserver.init/init"} ;; our custo immutant init function
  :profiles {:dev {:immutant {:context-path "/"</p>

<pre><code>                          :nrepl-port 4242
                          :lein-profiles [:dev]
                          :env :dev}}}) ;:dev will identify which config file to load
</code></pre>

<p>```</p>

<p>In this sample <code>project.clj</code> you find <code>:immutant</code> directly under the project definition. This key is used to, regardless of the environment, inform immutant which funtion to call when your app starts up. In this case <code>tserver.init/init</code>, that we will further analyze.</p>

<p>Pay attention to the <code>:env</code> entry. It is located under <code>:immutant</code> that is under <code>[:profiles :dev]</code>. Here enters a <a href="http://leiningen.org/">leiningen's</a> <a href="https://github.com/technomancy/leiningen/blob/stable/doc/PROFILES.md">profiles feature</a>. Where you can even specify dependencies or anything you want by profile. In this case, the immutant config is being configured by profile.</p>

<p><strong>Why not simply load a config per profile?</strong></p>

<p>Because you can combine <em>n</em> profiles at the sime time. So, which one to use as the enviroment reference? That is why I decided to use an specific entry for that.</p>

<p>Below the initial function being called by immutant. Here goes intereting stuff.
One of them is the use of <a href="http://clojuredocs.org/clojure_core/clojure.core/in-ns"><code>in-ns</code></a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/use"><code>use</code></a> and <a href="http://clojuredocs.org/clojure_core/clojure.core/require"><code>require</code></a>. This is awesome because I'm calling what could be "equivalent to a java import" in the middle of a clojure file, and even better: I'm doing this to another namespace that differs from the code that is actually calling the "imports".</p>

<p>So, <code>in-ns</code> will create the namespace <code>tserver.config</code> and "import" the appropriate functions and namespaces.</p>

<p>The <code>init</code> funtion here will simply call the <code>load-config</code>, that is in charge of loading the config file. Look:</p>

<p>``` clojure Silly Project
(ns tserver.init
  (:use [clojure.tools.logging :only (info error debug)]))</p>

<p>(defn setup-config-ns [e]</p>

<pre><code>(binding [*ns* *ns*]
  (in-ns 'tserver.config)
  (refer-clojure)
  (use '[clojure.main :only (load-script)])
  (require '[immutant.messaging :as msg]
           '[immutant.web :as web]
           '[immutant.util :as util])))
</code></pre>

<p>(defn load-config
  "Attempts to evaluate the specified env file defined by <code>:env</code>
  in the <code>project.clj</code>. <code>:env</code> is a immutant custom config.
  <code>:env</code> MUST be a keyword: Ex.: :dev, :prod :office
  Uses :dev by default.
  Note: The absence of the requrested file will prevent the server to start.
  These siles MUST be located at `src/tserver/config/%s.clj"
  []
  (binding [<em>ns</em> <em>ns</em>]</p>

<pre><code>(in-ns 'tserver.config)
(let [ev (get-in (immutant.registry/get :config) [:env] :dev)
        config-file (format "src/tserver/config/%s.clj" (name ev))]
  (setup-config-ns ev)
  (info "Using config file " config-file)
  (load-file config-file)
  (immutant.registry/put :env ev))))
</code></pre>

<p>(defn init []
  ;;may do some stuff before
  (load-config)) ;;may do some stuff after
```</p>

<p>And finally, our config file containing the required configurations. It can be anything you need.</p>

<p>``` clojure Silly Project
(defn handler</p>

<pre><code>[r] ((build-routes) r))
</code></pre>

<p>(web/start handler
  :reload true)</p>

<p>(msg/start "/queue/delivery.status")</p>

<p>(msg/respond "/queue/delivery.status" handle-delivery-status)</p>

<p>(register-job #'import-job)
(register-job #'check-import)
;register-job is function not provided here
;since the intention is tho show the configuration solution
```</p>

<p>Now, to deploy and start the app with the given profile we simply do:</p>

<p><code>bash
lein with-profile dev immutant deploy
lein immutant run
</code></p>

<p>Voila! This will load your <code>dev.clj</code> file and set up your queues, jobs, web-context, whatever you want. This is useful, and I would risk to say mandatory today. You probably have sereval environments where your app resides before going to prodution, and each of them with different names, addresses, pool sizes, queue names, database to connect, etc. And you can easily give to your app the intelligence to load what is more appropriate.</p>

<p><p>Don't forget to visit the <a href="/about">about</a> page. And follow me on Twitter: <a href="http://twitter.com/paulosuzart">@paulosuzart</a>.</p>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP Server with Clojure Aleph and Gloss]]></title>
    <link href="http://paulosuzart.github.com/blog/2012/07/09/tcp-server-with-clojure-aleph-and-gloss/"/>
    <updated>2012-07-09T11:57:00-03:00</updated>
    <id>http://paulosuzart.github.com/blog/2012/07/09/tcp-server-with-clojure-aleph-and-gloss</id>
    <content type="html"><![CDATA[<p>Hi Ho! Its been a long time without writing here. As you might know, I've just launched a new web/mobile <a href="http://www.guiato.com.br">(Guiato)</a> platform to help retailers reach their customers with their existing brochures/pamphlets/flyers but now, electronically.</p>

<p>It was as a 4 months adventure, including 20 days in Germany to plan and bring all the platform to Brazil. But now it is time to clojure a bit more. And we are just beginning.</p>

<p>My team and I have a simple google docs with amazing funny statements - or facts - we say. But it is too much sophisticated, so I decided to write our own system (Clacts) to register and read this facts using <a href="http://clojure.org">Clojure</a>, <a href="https://github.com/ztellman/aleph/wiki">Aleph</a> as TCP server, <a href="https://github.com/ztellman/gloss/wiki">Gloss</a> for encoding/decoding messages and <a href="http://www.sqlite.org/">SQLite</a> for storing facts. Amazing! Isn't it? :) Well at last it was funny.</p>

<p>I started creating a very simple protocol to allow clients to connect via telnet. So it is:</p>

<p>``` bash Clacts Protocol</p>

<p>PUT <author> <via> <fact>
LSA <author>|*</p>

<p><code>``
We have two main commands,</code>PUT<code>and</code>LSA<code>. For</code>PUT<code>, author is the guy speaking, via is who noted it, and the fact is the statement itself. And for</code>LSA<code>command, you can pass the author's name and the system will return all the facts spoken by the author.</code>*` means you want to read all the facts.</p>

<p>Any other command will be handled as error. Enter Gloss, a lib that allows you to draw how sequence of bytes will be converted to clojure data structures, and how clojure data will be converted to byte sequences. Here is the definition of Clacts the protocol:</p>

<p>``` clojure Clacts Protocol with Gloss</p>

<p>(def p (string :utf-8 :delimiters " "))
(def lp (string :utf-8 :delimiters ["\r\n"]))</p>

<p>(defcodec PUTC ["PUT" p p lp])
(defcodec LSAC ["LSA" lp])
(defcodec REPC ["REP" lp])
(defcodec LSRC ["LSR" (string :utf-8 :suffix " ")</p>

<pre><code>                  (string :utf-8 :suffix " ") 
                  (string :utf-8 :suffix " ") 
                  (string :utf-8 :suffix "\r\n")])
</code></pre>

<p>(defcodec ERRC (string :utf-8))</p>

<p>(defcodec CMDS
  (header</p>

<pre><code>p
(fn [h] (condp = h
    "PUT" PUTC 
    "LSA" LSAC 
    "REP" REPC
    "LSR" LSRC
    ERRC))
(fn [b] (first b))))
</code></pre>

<p>```</p>

<p>Gloss uses the concept of frames and codecs to model your bytes. As a shortcut, i'm using <code>p</code> and <code>lp</code> to identify parameters ended in <code>" "</code> and parameters ended in <code>\r\n</code>. That is, <code>p</code> and <code>lp</code> are frames that will be converted to strings, with UTF-8 encoding.</p>

<p>Given the building block frames <code>p</code> and <code>lp</code> we can start to form the commands. We have <code>PUTC</code>, a codec that is composed by the word <code>PUT</code> plus two <code>p</code> frames and one <code>lp</code> frame. So this: <code>PUT Agustinho Brisola Estou acostumado a criar my propria cloud</code>, will be converted to: <code>["PUT" "Agustinho" "Brisolla" "Estou acostumado a criar minha propria cloud"]</code>. Bang! We have bytes straight to a clojure vector. And testing it is pretty straight forward. Look:</p>

<p>``` clojure Testing codecs
(use 'gloss.core 'gloss.io)
(import java.nio.ByteBuffer)</p>

<p>(def buffer (java.nio.ByteBuffer/wrap (.getBytes "PUT Agustinho Brisolla Teste Fact\r\n")))</p>

<p>(decode PUTC buffer)</p>

<p>;; ["PUT" "PUT" "Agustinho" "Brisolla Teste Fact"]</p>

<p>```</p>

<p>There are actually more codecs (<code>REPC</code> and <code>LSRC</code>) to handle generic responses and <code>LSA</code> responses respectively. But once you understand the commands, the answers are natural consequences.</p>

<p>Hell yeah! Neat and handy. But clients can actually use different commands, how to understand which command to decode an handle appropriately?</p>

<p>For these cases (and others for sure) Gloss allows you to define a <code>header</code>, which is some part of the frame that behaves as an indicative for the rest of the frames. In this case, look to the codec <code>CMDS</code>. It is composed by a header that, depending on its content, indicates the other commands.</p>

<p>The <code>head</code> function is a bit strange at first, but once you get it, you can go really far. <code>head</code> takes 3 args, <em>(i)</em> its own frame, <em>(ii)</em> a function that given the header it points to the right codec for the rest of the message, and <em>(iii)</em> another function that given the body of a frame, extracts the value of the header. Easy?</p>

<p>Take <code>PUT Agustinho Brisolla Teste Fact\r\n</code> command as an example. <code>PUT</code> is extracted by this <code>string</code> calling <code>frist</code> on it. This is the function that maps the body to header. And given the header, that is a <code>p</code> (the first string separated by space), I check its value and return the appropriate codec: <code>PUTC</code>.</p>

<p>Note the default value for <code>ERRC</code>. This is for the cases where some smart user types an unknown command.</p>

<p>Great, but we have to handle the requests coming from telnet clients. Now it is Aleph time:</p>

<p>``` clojure Aleph TCP Server</p>

<p>(defn handler
  "TCP Handler. Decodes the issued command and calls the appropriate
  function to excetion some action."
  [ch ci]
  (receive-all ch</p>

<pre><code>(fn [b]
  (let [deced (decode prt/CMDS b)]
    (println "Processing command: " deced)
    (condp = (first deced)
      "PUT" (put-fact (rest deced) ch)
      "LSA" (list-facts (second deced) ch)
      (handle-err ch ci))))))
</code></pre>

<p>(start-tcp-server handler {:port 10000})</p>

<p>```</p>

<p>When you start the tcp server without defining the frame to handle, Aleph delivers to the <code>handler</code> a series of <code>ByteBuffers</code>, what is perfect for this case. The handler function decodes the frames against the <code>CMDS</code> codec and calls the correspondent function passing as argument the channel to respond to.</p>

<p>Not that there is a default function - <code>handle-err</code> being called in case of unknown commands. It will respond to clients random error messages.</p>

<p>The functions to list and put facts into the database use the same <code>CMDS</code> codec to encode reply messages. Look:</p>

<p>``` clojure Inserting facts and replying</p>

<p>(defn put-fact
  "Inserts the fact into db according to proto/PUTC.
  Takes the decoded data end the channel to respond."
  [data ch]
  (with-connection db</p>

<pre><code>(insert-record :facts
  {:date   (str (System/currentTimeMillis))
   :author (first data)
   :via    (second data)
   :fact   (last data)}))
</code></pre>

<p>  (enqueue ch (encode prt/CMDS ["REP" "Fact recorded!! Have fun with it."])))</p>

<p>```</p>

<p><code>REP</code> is a command encoded by <code>REPC</code> codec as defined above. The codec is defined by the header of the message (<code>REP</code>). What is pretty useful and saves your from using <code>if</code> to do that.</p>

<p>You may argue: "Why not use HTTP/Restful thing?" And I say: because this is more fun :)</p>

<p>You can find the full project on my github: <a href="https://github.com/paulosuzart/clact">https://github.com/paulosuzart/clact</a>. There you can see more details regarding interacting with SQLite, that wasn't covered here.</p>

<h1>UPDATE 2012/08/03</h1>

<p>The great brain <a href="http://twitter.com/ztellman">@ztellman</a>, the creator of gloss, gave me a hand <a href="https://github.com/paulosuzart/clact/pull/1">pulling</a> some changes in the code. What he suggested was to specify the frame for the server. So Aleph takes care of the protocol being encoded/decoded and you interact solely with clojure data structures. The change was:</p>

<p>``` clojure Zach suggestions
(start-tcp-server handler {:port (:port opts), :frame prt/CMDS})</p>

<p>;;what leads us to check for commands like this:</p>

<p>(receive-all ch</p>

<pre><code>(fn [cmd]
  (println "Processing command: " cmd "From " ci)
  (condp = (first cmd)
    "PUT" (put-fact (rest cmd) ch)
    "LSA" (list-facts (second cmd) ch)
    (handle-err ch ci)))))
</code></pre>

<p>;; instead of the previous version manually decoding bytes:</p>

<p>(receive-all ch
  (fn [b]</p>

<pre><code>(let [deced (decode prt/CMDS b)]
  (println "Processing command: " deced)
  (condp = (first deced)
    "PUT" (put-fact (rest deced) ch)
    "LSA" (list-facts (second deced) ch)
    (handle-err ch ci))))))
</code></pre>

<p>;;the same applies for sending response back to the client:</p>

<p>(enqueue broad-put ["REP"</p>

<pre><code>                (format "####Fact recorded by %s!! By %s: %s."
                 via author fact)]))
</code></pre>

<p>;; no need for manual encoding :)
```</p>

<p>This is great because the best thing on every clojure lib is use pure clojure data structures to keep things uniform.</p>

<p>Thanks to Zach for the precious tips.</p>

<p><p>Don't forget to visit the <a href="/about">about</a> page. And follow me on Twitter: <a href="http://twitter.com/paulosuzart">@paulosuzart</a>.</p>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monitoring ec2 with clojure and Server-Stats]]></title>
    <link href="http://paulosuzart.github.com/blog/2012/04/17/monitoring-ec2-with-clojure-and-server-stats/"/>
    <updated>2012-04-17T17:25:00-03:00</updated>
    <id>http://paulosuzart.github.com/blog/2012/04/17/monitoring-ec2-with-clojure-and-server-stats</id>
    <content type="html"><![CDATA[<h2>Intro</h2>

<p>Before going further, please take a look at <a href="http://info.rjmetrics.com/blog/bid/54114/Parallel-SSH-and-system-monitoring-in-Clojure">Parallel SSH and system monitoring in Clojure</a>.</p>

<p>Combining my need for monitoring an EC2 instance running <a href="http://nginx.org">nginx</a>, <a href="http://www.atlassian.com/software/bamboo/overview">bamboo</a> and <a href="http://www.jfrog.com/products.php">artifactory</a>, with my will to code in clojure, I have decided to use <a href="https://github.com/paulosuzart/Server-Stats">server-stats</a> to basic monitor my server via ssh.</p>

<p>EC2 supports interactions using SSH without need its <code>.pem</code> file if you add your public key to it. Take a look <a href="http://craiccomputing.blogspot.com.br/2009/07/rails-git-capistrano-ec2-and-ssh.html">here</a> to see how.</p>

<p>These are dead simple commands and of course you should use more serious ones for critical services.</p>

<p>The <code>server-stats</code> config file is actually a clojure file named <code>server-stats.cfg</code> where you put some definitions for monitoring. The strength of server-stats is the running it against several server. But in this case, I have just one.</p>

<h2>The config file</h2>

<p>``` clojure server-stats.cfg</p>

<p>(import org.apache.commons.mail.SimpleEmail)</p>

<p>(defn send-mail [alert-msg server-name cmd-output]</p>

<pre><code>(doto (SimpleEmail.)
 ;; ... my email configs
  (.send)))
</code></pre>

<p>(add-alert-handler email [alert-msg server-name cmd-output]
  (send-mail alert-msg server-name cmd-output))</p>

<p>(set-ssh-username "ec2-user")</p>

<p>(add-server-group web-servers
  ["myserver.mydomain.com"])</p>

<p>(add-cmd disk
  {:doc "Get the disk usage using df"
   :cmd "df -h"
   :servers [web-servers]
   :alerts [{:column "Use%"</p>

<pre><code>         :value-type percent
         :handlers [email]
         :msg "Disk space over 55% full"
         :trigger (&gt; 55)}]})
</code></pre>

<p>(add-cmd is-nginx
  {:doc "Is nginx Running?"
   :servers [web-servers]
   :cmd "[[ -z <code>ps aux | grep nginx</code> ]] &amp;&amp; echo 'false' || echo 'true'"
   :alerts [{:value-type bool</p>

<pre><code>         :msg "Nginx is not running"
         :handlers [email]
         :trigger (= false)}]})
</code></pre>

<p>(add-cmd app-log
  {:doc "Get last 20 entries in todays app-servers log"
   :servers [web-servers]
   :cmd "tail -20 /home/ec2-user/artifactory-2.5.1.1/logs/access.log"})</p>

<p>(add-cmd http-errors
  {:doc "Show recent non-200s requests"
   :servers [web-servers]
   :cmd "tail -200 /var/log/nginx/error.log"})</p>

<p>(add-cmd is-artifactory
  {:doc "Is Artifactory Running?"
   :servers [web-servers]
   :cmd "[[ -z <code>ps aux | grep org.artifactory.standalone.main.Main</code> ]] &amp;&amp; echo 'false' || echo 'true'"
   :alerts [{:value-type bool</p>

<pre><code>         :msg "Artifactory is not running"
         :handlers [email]
         :trigger (= false)
         :mute-for 1860000}]})
</code></pre>

<p>(add-cmd is-bamboo
  {:doc "Is bamboo Running?"
   :servers [web-servers]
   :cmd "[[ -z <code>ps aux | grep com.attlassian.bamboo.server.Server</code> ]] &amp;&amp; echo 'false' || echo 'true'"
   :alerts [{:value-type bool</p>

<pre><code>         :msg "Bamboo is not running"
         :handlers [email]
         :trigger (= false)
         :mute-for 1860000}]})
</code></pre>

<p>```</p>

<p>Almost all the commands were borrowed from the sample <code>cfg</code> file. A small but important detail is the key <code>:mute-for</code> in alerts. As you can see, the above link to server-stats points to my fork of it.</p>

<p>The <a href="https://github.com/RJMetrics/Server-Stats/pull/2"><code>mute-for</code></a> key adds the capability to prevent any scheduled <code>ssh</code> commands with short intervals to flood your alert communication channel (e-mail in this <code>cfg</code>). The alerts are sent only if the <code>mute-for</code> time has been elapsed.</p>

<p>This is done via empty files for controlling the alerts. <code>server-stats</code> checks the <code>lastModified</code> property of the file of a given alert, and activates the it only if the <code>mute-for</code> interval is over.</p>

<p>To make server-stats send alerts before the <code>:mute-for</code> time, you can just delete the file named <code>.{Sanitized_alert_message}</code>. The sanitized message is just the message alert message with no characters as underlines. I should consider a hash version of it to avoid big names for big messages, but it is ok for now.</p>

<p><strong>Note that <code>mute-for</code> controls the alert activation per <code>cmd</code> message.</strong></p>

<h2>Use cron</h2>

<p>Of course you can't spend your time issuing ssh commands by hand. So, there are four <code>cron</code> entries for scheduled ssh interactions:</p>

<p>``` bash crontab</p>

<p>0 7 * * * SSH_AUTH_SOCK="$(find /tmp/keyring<em>/ -type s -user paulosuzart -group paulosuzart  -name 'ssh</em>' | head -n 1)" ~/workspace/p/Server-Stats/run.sh disk -log
<em>/10 * * * * SSH_AUTH_SOCK="$(find /tmp/keyring</em>/ -type s -user paulosuzart -group paulosuzart  -name 'ssh<em>' | head -n 1)" ~/workspace/p/Server-Stats/run.sh is-nginx -log
</em>/30 * * * * SSH_AUTH_SOCK="$(find /tmp/keyring<em>/ -type s -user paulosuzart -group paulosuzart  -name 'ssh</em>' | head -n 1)" ~/workspace/p/Server-Stats/run.sh is-artifactory -log
<em>/30 * * * * SSH_AUTH_SOCK="$(find /tmp/keyring</em>/ -type s -user paulosuzart -group paulosuzart  -name 'ssh*' | head -n 1)" ~/workspace/p/Server-Stats/run.sh is-bamboo -log</p>

<p>```</p>

<p>The <code>run.sh</code> is pretty simple. Just wraps <code>java -jar</code> to server-stats. Some times I want to log the ssh output, so I can pass the <code>-log</code> option and the output goes to <code>log/cmd</code>.</p>

<p>``` bash run.sh</p>

<h1>!/bin/bash</h1>

<h1>Wraps the start of server-stats. If -log is passed, will save</h1>

<h1>the resulting execution to log/cmd</h1>

<h1>paulosuzart@gmail.com</h1>

<h1>java -jar should run from inside the server-stats dir</h1>

<p>cd ~/workspace/p/Server-Stats</p>

<p>if [ -z $1 ]; then
  echo "usage: run cmd [-log]"
  exit 2
fi</p>

<p>COMM="java -jar server-stats-0.1-standalone.jar -a $1"
if [[ ! -z $2 &amp;&amp; "-log"=$2 ]]; then
  echo "logging to log/$1.out"
  $COMM=$COMM:" > log/$1.out"
fi</p>

<p>echo $COMM
$COMM</p>

<p>```</p>

<p>Don't ask me why, but <code>ssh</code> does not behave the way you except when called from a <code>cron</code> command. But I managed to find <a href="http://webcache.googleusercontent.com/search?q=cache:7h4hOIGZG-wJ:www.codealpha.net/163/cron-ssh-and-rsync-and-key-with-passphrase-ubuntu/+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;client=ubuntu">this article</a> that helped a lot.</p>

<p>This <code>crontable</code> is configured on my laptop and any strange behavior is sent to my e-mail immediately. The other <code>cmds</code> (<code>app-log</code>, <code>http-errors</code>) are used directly with <code>./run.sh cmd</code> to see the output.</p>

<h2>Conclusion</h2>

<p>Of course the <code>mute-for</code> feature <a href="https://github.com/RJMetrics/Server-Stats/pull/2">might be merged</a> to the original repo. So, I would recommend you to use the original version of server-stats.</p>

<p>If you need simple monitoring features or more elaborated ones, it is up to you. Just use server-stats as the  base for it.</p>

<h2>Update</h2>

<p>This post was republished <a href="http://www.dzone.com">Dzone</a>. See <a href="http://architects.dzone.com/articles/how-monitoring-ec2-clojure-and">here</a>.</p>

<p><p>Don't forget to visit the <a href="/about">about</a> page. And follow me on Twitter: <a href="http://twitter.com/paulosuzart">@paulosuzart</a>.</p>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sorting with clojure comparator]]></title>
    <link href="http://paulosuzart.github.com/blog/2012/04/11/sorting-with-clojure-comparator/"/>
    <updated>2012-04-11T22:51:00-03:00</updated>
    <id>http://paulosuzart.github.com/blog/2012/04/11/sorting-with-clojure-comparator</id>
    <content type="html"><![CDATA[<p>This is a quick post to show an example of <a href="http://clojure.org">clojure</a> <code>comparator</code> for sorting a list with <code>sort</code>.</p>

<p>At work a friend wrote dozen lines of java to sort a list of characters that represents t-shirt sizes. The sizes are: pp, p, m, mm, g, gg, a, aa. Where 'pp' is super small, 'p' small, 'm' medium, etc.</p>

<p>Some shees have all the sizes available, some not. So imagine a shirt with just g, a, gg, p sizes availabe. The screen should show: p, g, gg, a.</p>

<p>He requested me to do a clojure version of it. Here it goes.</p>

<p><div><script src='https://gist.github.com/2351780.js?file='></script>
<noscript><pre><code></code></pre></noscript></div>
</p>

<p>The first useful function is <a href="http://clojuredocs.org/clojure_core/clojure.core/map-indexed"><code>map-indexed</code></a>. Since the order of sizes is not natural, we associate numbers to them given we know the size order. So <code>sizes</code> becomes <code>{:a 6, :gg 5, :g 4, :pp 0, :m 2, :mm 3, :aa 7, :p 1}</code>.</p>

<p>Then I used a <a href="http://clojuredocs.org/clojure_core/clojure.core/comparator"><code>comparator</code></a>. It produces a <code>java.util.Comparator</code> for the given function. In this case the comparison of the map values for each key.</p>

<p>To finish that, the <a href="http://clojuredocs.org/clojure_core/clojure.core/sort"><code>sort</code></a> function. It takes a given product sizes list and sorts then. So <code>'(p, g, gg, aa)</code> becomes <code>(p g gg a)</code>.</p>

<p>It is even silly for a blog post but what if I can convince him to replace the java methods/utils/whatever methods for a <a href="http://clojuredocs.org/clojure_core/clojure.core/gen-class"><code>gen-class</code></a> of it? Packing compiled clojure code and using them for utility functions and small piece of your application can be a good way to get used to the language and confidence to start a full application in it.</p>

<p>Actually to let this code reusable, one can take the list of sizes instead of hard coding it. But this is an exercise for you.</p>

<p><p>Don't forget to visit the <a href="/about">about</a> page. And follow me on Twitter: <a href="http://twitter.com/paulosuzart">@paulosuzart</a>.</p>
</p>

<p><em>Thanks to USA guys, you are the top visitors here. Thank you very much.</em></p>
]]></content>
  </entry>
  
</feed>
