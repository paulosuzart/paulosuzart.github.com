<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Paulo Suzart Blog]]></title>
  <link href="http://paulosuzart.github.com/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://paulosuzart.github.com/"/>
  <updated>2013-08-22T00:04:42-03:00</updated>
  <id>http://paulosuzart.github.com/</id>
  <author>
    <name><![CDATA[Paulo Suzart]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Configuring Clojure Immutant by environment]]></title>
    <link href="http://paulosuzart.github.com/blog/2013/02/07/configuring-clojure-immutant-by-environment/"/>
    <updated>2013-02-07T08:39:00-02:00</updated>
    <id>http://paulosuzart.github.com/blog/2013/02/07/configuring-clojure-immutant-by-environment</id>
    <content type="html"><![CDATA[<p>Hi again! Not posting for too much long.</p>

<p>Well, this time we will explore the <a href="http://clojure.org">clojure's</a> ability to <a href="http://clojuredocs.org/clojure_core/clojure.core/load-file">load arbitrary files as code</a>.</p>

<p>This is such an amazing feature, but you should be careful. Don't start reading anyones files and evaluating them into your app. Be wise and use it for specific situation like this: I wanted to load a bunch of configurations (and even funtion calls) depending on the environment my app is running.</p>

<p>To do the conditional evaluation, I decided to add an extra key to <code>:immutant</code> entry in my project definition. The entry <code>:env</code> is an <a href="http://immutant.org/documentation/current/initialization.html#sec-3-1">arbitrary configuration value</a>. Lets take a look:</p>

<p>``` clojure Silly Project
(defproject tserver "0.1.0-SNAPSHOT"
  :description "A foo project"
  :url "http://foo.com/"
  :license {:name "Eclipse Public License"</p>

<pre><code>        :url "http://www.eclipse.org/legal/epl-v10.html"}
</code></pre>

<p>  :dependencies [[org.clojure/clojure "1.4.0"]</p>

<pre><code>             [compojure "1.0.2"]
             ;... and many other dependecies
</code></pre>

<p>  :jvm-opts ["-Xmx2g" "-server"]
  :immutant {:init "tserver.init/init"} ;; our custo immutant init function
  :profiles {:dev {:immutant {:context-path "/"</p>

<pre><code>                          :nrepl-port 4242
                          :lein-profiles [:dev]
                          :env :dev}}}) ;:dev will identify which config file to load
</code></pre>

<p>```</p>

<p>In this sample <code>project.clj</code> you find <code>:immutant</code> directly under the project definition. This key is used to, regardless of the environment, inform immutant which funtion to call when your app starts up. In this case <code>tserver.init/init</code>, that we will further analyze.</p>

<p>Pay attention to the <code>:env</code> entry. It is located under <code>:immutant</code> that is under <code>[:profiles :dev]</code>. Here enters a <a href="http://leiningen.org/">leiningen's</a> <a href="https://github.com/technomancy/leiningen/blob/stable/doc/PROFILES.md">profiles feature</a>. Where you can even specify dependencies or anything you want by profile. In this case, the immutant config is being configured by profile.</p>

<p><strong>Why not simply load a config per profile?</strong></p>

<p>Because you can combine <em>n</em> profiles at the sime time. So, which one to use as the enviroment reference? That is why I decided to use an specific entry for that.</p>

<p>Below the initial function being called by immutant. Here goes intereting stuff.
One of them is the use of <a href="http://clojuredocs.org/clojure_core/clojure.core/in-ns"><code>in-ns</code></a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/use"><code>use</code></a> and <a href="http://clojuredocs.org/clojure_core/clojure.core/require"><code>require</code></a>. This is awesome because I'm calling what could be "equivalent to a java import" in the middle of a clojure file, and even better: I'm doing this to another namespace that differs from the code that is actually calling the "imports".</p>

<p>So, <code>in-ns</code> will create the namespace <code>tserver.config</code> and "import" the appropriate functions and namespaces.</p>

<p>The <code>init</code> funtion here will simply call the <code>load-config</code>, that is in charge of loading the config file. Look:</p>

<p>``` clojure Silly Project
(ns tserver.init
  (:use [clojure.tools.logging :only (info error debug)]))</p>

<p>(defn setup-config-ns [e]</p>

<pre><code>(binding [*ns* *ns*]
  (in-ns 'tserver.config)
  (refer-clojure)
  (use '[clojure.main :only (load-script)])
  (require '[immutant.messaging :as msg]
           '[immutant.web :as web]
           '[immutant.util :as util])))
</code></pre>

<p>(defn load-config
  "Attempts to evaluate the specified env file defined by <code>:env</code>
  in the <code>project.clj</code>. <code>:env</code> is a immutant custom config.
  <code>:env</code> MUST be a keyword: Ex.: :dev, :prod :office
  Uses :dev by default.
  Note: The absence of the requrested file will prevent the server to start.
  These siles MUST be located at `src/tserver/config/%s.clj"
  []
  (binding [<em>ns</em> <em>ns</em>]</p>

<pre><code>(in-ns 'tserver.config)
(let [ev (get-in (immutant.registry/get :config) [:env] :dev)
        config-file (format "src/tserver/config/%s.clj" (name ev))]
  (setup-config-ns ev)
  (info "Using config file " config-file)
  (load-file config-file)
  (immutant.registry/put :env ev))))
</code></pre>

<p>(defn init []
  ;;may do some stuff before
  (load-config)) ;;may do some stuff after
```</p>

<p>And finally, our config file containing the required configurations. It can be anything you need.</p>

<p>``` clojure Silly Project
(defn handler</p>

<pre><code>[r] ((build-routes) r))
</code></pre>

<p>(web/start handler
  :reload true)</p>

<p>(msg/start "/queue/delivery.status")</p>

<p>(msg/respond "/queue/delivery.status" handle-delivery-status)</p>

<p>(register-job #'import-job)
(register-job #'check-import)
;register-job is function not provided here
;since the intention is tho show the configuration solution
```</p>

<p>Now, to deploy and start the app with the given profile we simply do:</p>

<p><code>bash
lein with-profile dev immutant deploy
lein immutant run
</code></p>

<p>Voila! This will load your <code>dev.clj</code> file and set up your queues, jobs, web-context, whatever you want. This is useful, and I would risk to say mandatory today. You probably have sereval environments where your app resides before going to prodution, and each of them with different names, addresses, pool sizes, queue names, database to connect, etc. And you can easily give to your app the intelligence to load what is more appropriate.</p>

<p><p>Don't forget to visit the <a href="/about">about</a> page. And follow me on Twitter: <a href="http://twitter.com/paulosuzart">@paulosuzart</a>.</p>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP Server with Clojure Aleph and Gloss]]></title>
    <link href="http://paulosuzart.github.com/blog/2012/07/09/tcp-server-with-clojure-aleph-and-gloss/"/>
    <updated>2012-07-09T11:57:00-03:00</updated>
    <id>http://paulosuzart.github.com/blog/2012/07/09/tcp-server-with-clojure-aleph-and-gloss</id>
    <content type="html"><![CDATA[<p>Hi Ho! Its been a long time without writing here. As you might know, I've just launched a new web/mobile <a href="http://www.guiato.com.br">(Guiato)</a> platform to help retailers reach their customers with their existing brochures/pamphlets/flyers but now, electronically.</p>

<p>It was as a 4 months adventure, including 20 days in Germany to plan and bring all the platform to Brazil. But now it is time to clojure a bit more. And we are just beginning.</p>

<p>My team and I have a simple google docs with amazing funny statements - or facts - we say. But it is too much sophisticated, so I decided to write our own system (Clacts) to register and read this facts using <a href="http://clojure.org">Clojure</a>, <a href="https://github.com/ztellman/aleph/wiki">Aleph</a> as TCP server, <a href="https://github.com/ztellman/gloss/wiki">Gloss</a> for encoding/decoding messages and <a href="http://www.sqlite.org/">SQLite</a> for storing facts. Amazing! Isn't it? :) Well at last it was funny.</p>

<p>I started creating a very simple protocol to allow clients to connect via telnet. So it is:</p>

<p>``` bash Clacts Protocol</p>

<p>PUT <author> <via> <fact>
LSA <author>|*</p>

<p><code>``
We have two main commands,</code>PUT<code>and</code>LSA<code>. For</code>PUT<code>, author is the guy speaking, via is who noted it, and the fact is the statement itself. And for</code>LSA<code>command, you can pass the author's name and the system will return all the facts spoken by the author.</code>*` means you want to read all the facts.</p>

<p>Any other command will be handled as error. Enter Gloss, a lib that allows you to draw how sequence of bytes will be converted to clojure data structures, and how clojure data will be converted to byte sequences. Here is the definition of Clacts the protocol:</p>

<p>``` clojure Clacts Protocol with Gloss</p>

<p>(def p (string :utf-8 :delimiters " "))
(def lp (string :utf-8 :delimiters ["\r\n"]))</p>

<p>(defcodec PUTC ["PUT" p p lp])
(defcodec LSAC ["LSA" lp])
(defcodec REPC ["REP" lp])
(defcodec LSRC ["LSR" (string :utf-8 :suffix " ")</p>

<pre><code>                  (string :utf-8 :suffix " ") 
                  (string :utf-8 :suffix " ") 
                  (string :utf-8 :suffix "\r\n")])
</code></pre>

<p>(defcodec ERRC (string :utf-8))</p>

<p>(defcodec CMDS
  (header</p>

<pre><code>p
(fn [h] (condp = h
    "PUT" PUTC 
    "LSA" LSAC 
    "REP" REPC
    "LSR" LSRC
    ERRC))
(fn [b] (first b))))
</code></pre>

<p>```</p>

<p>Gloss uses the concept of frames and codecs to model your bytes. As a shortcut, i'm using <code>p</code> and <code>lp</code> to identify parameters ended in <code>" "</code> and parameters ended in <code>\r\n</code>. That is, <code>p</code> and <code>lp</code> are frames that will be converted to strings, with UTF-8 encoding.</p>

<p>Given the building block frames <code>p</code> and <code>lp</code> we can start to form the commands. We have <code>PUTC</code>, a codec that is composed by the word <code>PUT</code> plus two <code>p</code> frames and one <code>lp</code> frame. So this: <code>PUT Agustinho Brisola Estou acostumado a criar my propria cloud</code>, will be converted to: <code>["PUT" "Agustinho" "Brisolla" "Estou acostumado a criar minha propria cloud"]</code>. Bang! We have bytes straight to a clojure vector. And testing it is pretty straight forward. Look:</p>

<p>``` clojure Testing codecs
(use 'gloss.core 'gloss.io)
(import java.nio.ByteBuffer)</p>

<p>(def buffer (java.nio.ByteBuffer/wrap (.getBytes "PUT Agustinho Brisolla Teste Fact\r\n")))</p>

<p>(decode PUTC buffer)</p>

<p>;; ["PUT" "PUT" "Agustinho" "Brisolla Teste Fact"]</p>

<p>```</p>

<p>There are actually more codecs (<code>REPC</code> and <code>LSRC</code>) to handle generic responses and <code>LSA</code> responses respectively. But once you understand the commands, the answers are natural consequences.</p>

<p>Hell yeah! Neat and handy. But clients can actually use different commands, how to understand which command to decode an handle appropriately?</p>

<p>For these cases (and others for sure) Gloss allows you to define a <code>header</code>, which is some part of the frame that behaves as an indicative for the rest of the frames. In this case, look to the codec <code>CMDS</code>. It is composed by a header that, depending on its content, indicates the other commands.</p>

<p>The <code>head</code> function is a bit strange at first, but once you get it, you can go really far. <code>head</code> takes 3 args, <em>(i)</em> its own frame, <em>(ii)</em> a function that given the header it points to the right codec for the rest of the message, and <em>(iii)</em> another function that given the body of a frame, extracts the value of the header. Easy?</p>

<p>Take <code>PUT Agustinho Brisolla Teste Fact\r\n</code> command as an example. <code>PUT</code> is extracted by this <code>string</code> calling <code>frist</code> on it. This is the function that maps the body to header. And given the header, that is a <code>p</code> (the first string separated by space), I check its value and return the appropriate codec: <code>PUTC</code>.</p>

<p>Note the default value for <code>ERRC</code>. This is for the cases where some smart user types an unknown command.</p>

<p>Great, but we have to handle the requests coming from telnet clients. Now it is Aleph time:</p>

<p>``` clojure Aleph TCP Server</p>

<p>(defn handler
  "TCP Handler. Decodes the issued command and calls the appropriate
  function to excetion some action."
  [ch ci]
  (receive-all ch</p>

<pre><code>(fn [b]
  (let [deced (decode prt/CMDS b)]
    (println "Processing command: " deced)
    (condp = (first deced)
      "PUT" (put-fact (rest deced) ch)
      "LSA" (list-facts (second deced) ch)
      (handle-err ch ci))))))
</code></pre>

<p>(start-tcp-server handler {:port 10000})</p>

<p>```</p>

<p>When you start the tcp server without defining the frame to handle, Aleph delivers to the <code>handler</code> a series of <code>ByteBuffers</code>, what is perfect for this case. The handler function decodes the frames against the <code>CMDS</code> codec and calls the correspondent function passing as argument the channel to respond to.</p>

<p>Not that there is a default function - <code>handle-err</code> being called in case of unknown commands. It will respond to clients random error messages.</p>

<p>The functions to list and put facts into the database use the same <code>CMDS</code> codec to encode reply messages. Look:</p>

<p>``` clojure Inserting facts and replying</p>

<p>(defn put-fact
  "Inserts the fact into db according to proto/PUTC.
  Takes the decoded data end the channel to respond."
  [data ch]
  (with-connection db</p>

<pre><code>(insert-record :facts
  {:date   (str (System/currentTimeMillis))
   :author (first data)
   :via    (second data)
   :fact   (last data)}))
</code></pre>

<p>  (enqueue ch (encode prt/CMDS ["REP" "Fact recorded!! Have fun with it."])))</p>

<p>```</p>

<p><code>REP</code> is a command encoded by <code>REPC</code> codec as defined above. The codec is defined by the header of the message (<code>REP</code>). What is pretty useful and saves your from using <code>if</code> to do that.</p>

<p>You may argue: "Why not use HTTP/Restful thing?" And I say: because this is more fun :)</p>

<p>You can find the full project on my github: <a href="https://github.com/paulosuzart/clact">https://github.com/paulosuzart/clact</a>. There you can see more details regarding interacting with SQLite, that wasn't covered here.</p>

<h1>UPDATE 2012/08/03</h1>

<p>The great brain <a href="http://twitter.com/ztellman">@ztellman</a>, the creator of gloss, gave me a hand <a href="https://github.com/paulosuzart/clact/pull/1">pulling</a> some changes in the code. What he suggested was to specify the frame for the server. So Aleph takes care of the protocol being encoded/decoded and you interact solely with clojure data structures. The change was:</p>

<p>``` clojure Zach suggestions
(start-tcp-server handler {:port (:port opts), :frame prt/CMDS})</p>

<p>;;what leads us to check for commands like this:</p>

<p>(receive-all ch</p>

<pre><code>(fn [cmd]
  (println "Processing command: " cmd "From " ci)
  (condp = (first cmd)
    "PUT" (put-fact (rest cmd) ch)
    "LSA" (list-facts (second cmd) ch)
    (handle-err ch ci)))))
</code></pre>

<p>;; instead of the previous version manually decoding bytes:</p>

<p>(receive-all ch
  (fn [b]</p>

<pre><code>(let [deced (decode prt/CMDS b)]
  (println "Processing command: " deced)
  (condp = (first deced)
    "PUT" (put-fact (rest deced) ch)
    "LSA" (list-facts (second deced) ch)
    (handle-err ch ci))))))
</code></pre>

<p>;;the same applies for sending response back to the client:</p>

<p>(enqueue broad-put ["REP"</p>

<pre><code>                (format "####Fact recorded by %s!! By %s: %s."
                 via author fact)]))
</code></pre>

<p>;; no need for manual encoding :)
```</p>

<p>This is great because the best thing on every clojure lib is use pure clojure data structures to keep things uniform.</p>

<p>Thanks to Zach for the precious tips.</p>

<p><p>Don't forget to visit the <a href="/about">about</a> page. And follow me on Twitter: <a href="http://twitter.com/paulosuzart">@paulosuzart</a>.</p>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monitoring ec2 with clojure and Server-Stats]]></title>
    <link href="http://paulosuzart.github.com/blog/2012/04/17/monitoring-ec2-with-clojure-and-server-stats/"/>
    <updated>2012-04-17T17:25:00-03:00</updated>
    <id>http://paulosuzart.github.com/blog/2012/04/17/monitoring-ec2-with-clojure-and-server-stats</id>
    <content type="html"><![CDATA[<h2>Intro</h2>

<p>Before going further, please take a look at <a href="http://info.rjmetrics.com/blog/bid/54114/Parallel-SSH-and-system-monitoring-in-Clojure">Parallel SSH and system monitoring in Clojure</a>.</p>

<p>Combining my need for monitoring an EC2 instance running <a href="http://nginx.org">nginx</a>, <a href="http://www.atlassian.com/software/bamboo/overview">bamboo</a> and <a href="http://www.jfrog.com/products.php">artifactory</a>, with my will to code in clojure, I have decided to use <a href="https://github.com/paulosuzart/Server-Stats">server-stats</a> to basic monitor my server via ssh.</p>

<p>EC2 supports interactions using SSH without need its <code>.pem</code> file if you add your public key to it. Take a look <a href="http://craiccomputing.blogspot.com.br/2009/07/rails-git-capistrano-ec2-and-ssh.html">here</a> to see how.</p>

<p>These are dead simple commands and of course you should use more serious ones for critical services.</p>

<p>The <code>server-stats</code> config file is actually a clojure file named <code>server-stats.cfg</code> where you put some definitions for monitoring. The strength of server-stats is the running it against several server. But in this case, I have just one.</p>

<h2>The config file</h2>

<p>``` clojure server-stats.cfg</p>

<p>(import org.apache.commons.mail.SimpleEmail)</p>

<p>(defn send-mail [alert-msg server-name cmd-output]</p>

<pre><code>(doto (SimpleEmail.)
 ;; ... my email configs
  (.send)))
</code></pre>

<p>(add-alert-handler email [alert-msg server-name cmd-output]
  (send-mail alert-msg server-name cmd-output))</p>

<p>(set-ssh-username "ec2-user")</p>

<p>(add-server-group web-servers
  ["myserver.mydomain.com"])</p>

<p>(add-cmd disk
  {:doc "Get the disk usage using df"
   :cmd "df -h"
   :servers [web-servers]
   :alerts [{:column "Use%"</p>

<pre><code>         :value-type percent
         :handlers [email]
         :msg "Disk space over 55% full"
         :trigger (&gt; 55)}]})
</code></pre>

<p>(add-cmd is-nginx
  {:doc "Is nginx Running?"
   :servers [web-servers]
   :cmd "[[ -z <code>ps aux | grep nginx</code> ]] &amp;&amp; echo 'false' || echo 'true'"
   :alerts [{:value-type bool</p>

<pre><code>         :msg "Nginx is not running"
         :handlers [email]
         :trigger (= false)}]})
</code></pre>

<p>(add-cmd app-log
  {:doc "Get last 20 entries in todays app-servers log"
   :servers [web-servers]
   :cmd "tail -20 /home/ec2-user/artifactory-2.5.1.1/logs/access.log"})</p>

<p>(add-cmd http-errors
  {:doc "Show recent non-200s requests"
   :servers [web-servers]
   :cmd "tail -200 /var/log/nginx/error.log"})</p>

<p>(add-cmd is-artifactory
  {:doc "Is Artifactory Running?"
   :servers [web-servers]
   :cmd "[[ -z <code>ps aux | grep org.artifactory.standalone.main.Main</code> ]] &amp;&amp; echo 'false' || echo 'true'"
   :alerts [{:value-type bool</p>

<pre><code>         :msg "Artifactory is not running"
         :handlers [email]
         :trigger (= false)
         :mute-for 1860000}]})
</code></pre>

<p>(add-cmd is-bamboo
  {:doc "Is bamboo Running?"
   :servers [web-servers]
   :cmd "[[ -z <code>ps aux | grep com.attlassian.bamboo.server.Server</code> ]] &amp;&amp; echo 'false' || echo 'true'"
   :alerts [{:value-type bool</p>

<pre><code>         :msg "Bamboo is not running"
         :handlers [email]
         :trigger (= false)
         :mute-for 1860000}]})
</code></pre>

<p>```</p>

<p>Almost all the commands were borrowed from the sample <code>cfg</code> file. A small but important detail is the key <code>:mute-for</code> in alerts. As you can see, the above link to server-stats points to my fork of it.</p>

<p>The <a href="https://github.com/RJMetrics/Server-Stats/pull/2"><code>mute-for</code></a> key adds the capability to prevent any scheduled <code>ssh</code> commands with short intervals to flood your alert communication channel (e-mail in this <code>cfg</code>). The alerts are sent only if the <code>mute-for</code> time has been elapsed.</p>

<p>This is done via empty files for controlling the alerts. <code>server-stats</code> checks the <code>lastModified</code> property of the file of a given alert, and activates the it only if the <code>mute-for</code> interval is over.</p>

<p>To make server-stats send alerts before the <code>:mute-for</code> time, you can just delete the file named <code>.{Sanitized_alert_message}</code>. The sanitized message is just the message alert message with no characters as underlines. I should consider a hash version of it to avoid big names for big messages, but it is ok for now.</p>

<p><strong>Note that <code>mute-for</code> controls the alert activation per <code>cmd</code> message.</strong></p>

<h2>Use cron</h2>

<p>Of course you can't spend your time issuing ssh commands by hand. So, there are four <code>cron</code> entries for scheduled ssh interactions:</p>

<p>``` bash crontab</p>

<p>0 7 * * * SSH_AUTH_SOCK="$(find /tmp/keyring<em>/ -type s -user paulosuzart -group paulosuzart  -name 'ssh</em>' | head -n 1)" ~/workspace/p/Server-Stats/run.sh disk -log
<em>/10 * * * * SSH_AUTH_SOCK="$(find /tmp/keyring</em>/ -type s -user paulosuzart -group paulosuzart  -name 'ssh<em>' | head -n 1)" ~/workspace/p/Server-Stats/run.sh is-nginx -log
</em>/30 * * * * SSH_AUTH_SOCK="$(find /tmp/keyring<em>/ -type s -user paulosuzart -group paulosuzart  -name 'ssh</em>' | head -n 1)" ~/workspace/p/Server-Stats/run.sh is-artifactory -log
<em>/30 * * * * SSH_AUTH_SOCK="$(find /tmp/keyring</em>/ -type s -user paulosuzart -group paulosuzart  -name 'ssh*' | head -n 1)" ~/workspace/p/Server-Stats/run.sh is-bamboo -log</p>

<p>```</p>

<p>The <code>run.sh</code> is pretty simple. Just wraps <code>java -jar</code> to server-stats. Some times I want to log the ssh output, so I can pass the <code>-log</code> option and the output goes to <code>log/cmd</code>.</p>

<p>``` bash run.sh</p>

<h1>!/bin/bash</h1>

<h1>Wraps the start of server-stats. If -log is passed, will save</h1>

<h1>the resulting execution to log/cmd</h1>

<h1>paulosuzart@gmail.com</h1>

<h1>java -jar should run from inside the server-stats dir</h1>

<p>cd ~/workspace/p/Server-Stats</p>

<p>if [ -z $1 ]; then
  echo "usage: run cmd [-log]"
  exit 2
fi</p>

<p>COMM="java -jar server-stats-0.1-standalone.jar -a $1"
if [[ ! -z $2 &amp;&amp; "-log"=$2 ]]; then
  echo "logging to log/$1.out"
  $COMM=$COMM:" > log/$1.out"
fi</p>

<p>echo $COMM
$COMM</p>

<p>```</p>

<p>Don't ask me why, but <code>ssh</code> does not behave the way you except when called from a <code>cron</code> command. But I managed to find <a href="http://webcache.googleusercontent.com/search?q=cache:7h4hOIGZG-wJ:www.codealpha.net/163/cron-ssh-and-rsync-and-key-with-passphrase-ubuntu/+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;client=ubuntu">this article</a> that helped a lot.</p>

<p>This <code>crontable</code> is configured on my laptop and any strange behavior is sent to my e-mail immediately. The other <code>cmds</code> (<code>app-log</code>, <code>http-errors</code>) are used directly with <code>./run.sh cmd</code> to see the output.</p>

<h2>Conclusion</h2>

<p>Of course the <code>mute-for</code> feature <a href="https://github.com/RJMetrics/Server-Stats/pull/2">might be merged</a> to the original repo. So, I would recommend you to use the original version of server-stats.</p>

<p>If you need simple monitoring features or more elaborated ones, it is up to you. Just use server-stats as the  base for it.</p>

<h2>Update</h2>

<p>This post was republished <a href="http://www.dzone.com">Dzone</a>. See <a href="http://architects.dzone.com/articles/how-monitoring-ec2-clojure-and">here</a>.</p>

<p><p>Don't forget to visit the <a href="/about">about</a> page. And follow me on Twitter: <a href="http://twitter.com/paulosuzart">@paulosuzart</a>.</p>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sorting with clojure comparator]]></title>
    <link href="http://paulosuzart.github.com/blog/2012/04/11/sorting-with-clojure-comparator/"/>
    <updated>2012-04-11T22:51:00-03:00</updated>
    <id>http://paulosuzart.github.com/blog/2012/04/11/sorting-with-clojure-comparator</id>
    <content type="html"><![CDATA[<p>This is a quick post to show an example of <a href="http://clojure.org">clojure</a> <code>comparator</code> for sorting a list with <code>sort</code>.</p>

<p>At work a friend wrote dozen lines of java to sort a list of characters that represents t-shirt sizes. The sizes are: pp, p, m, mm, g, gg, a, aa. Where 'pp' is super small, 'p' small, 'm' medium, etc.</p>

<p>Some shees have all the sizes available, some not. So imagine a shirt with just g, a, gg, p sizes availabe. The screen should show: p, g, gg, a.</p>

<p>He requested me to do a clojure version of it. Here it goes.</p>

<p><div><script src='https://gist.github.com/2351780.js?file='></script>
<noscript><pre><code></code></pre></noscript></div>
</p>

<p>The first useful function is <a href="http://clojuredocs.org/clojure_core/clojure.core/map-indexed"><code>map-indexed</code></a>. Since the order of sizes is not natural, we associate numbers to them given we know the size order. So <code>sizes</code> becomes <code>{:a 6, :gg 5, :g 4, :pp 0, :m 2, :mm 3, :aa 7, :p 1}</code>.</p>

<p>Then I used a <a href="http://clojuredocs.org/clojure_core/clojure.core/comparator"><code>comparator</code></a>. It produces a <code>java.util.Comparator</code> for the given function. In this case the comparison of the map values for each key.</p>

<p>To finish that, the <a href="http://clojuredocs.org/clojure_core/clojure.core/sort"><code>sort</code></a> function. It takes a given product sizes list and sorts then. So <code>'(p, g, gg, aa)</code> becomes <code>(p g gg a)</code>.</p>

<p>It is even silly for a blog post but what if I can convince him to replace the java methods/utils/whatever methods for a <a href="http://clojuredocs.org/clojure_core/clojure.core/gen-class"><code>gen-class</code></a> of it? Packing compiled clojure code and using them for utility functions and small piece of your application can be a good way to get used to the language and confidence to start a full application in it.</p>

<p>Actually to let this code reusable, one can take the list of sizes instead of hard coding it. But this is an exercise for you.</p>

<p><p>Don't forget to visit the <a href="/about">about</a> page. And follow me on Twitter: <a href="http://twitter.com/paulosuzart">@paulosuzart</a>.</p>
</p>

<p><em>Thanks to USA guys, you are the top visitors here. Thank you very much.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lazy-seqs from database with clojure korma]]></title>
    <link href="http://paulosuzart.github.com/blog/2012/03/27/lazy-seqs-from-database-with-clojure-korma/"/>
    <updated>2012-03-27T20:54:00-03:00</updated>
    <id>http://paulosuzart.github.com/blog/2012/03/27/lazy-seqs-from-database-with-clojure-korma</id>
    <content type="html"><![CDATA[<p>As you may know, I've started in a new company last early this month. It is being a huge change in all aspects, technology, people, process, environment, etc.</p>

<p>Well, this week I wanted to migrate some data (900k rows) from a <a href="http://mysql.com/">MySQL</a> database to a <a href="www.postgresql.org">Postgres</a> one. <a href="twitter.com/felipejcruz">@felipejcruz</a> recommended <a href="http://pypi.python.org/pypi/py-mysql2pgsql">py-mysql2pgsql</a>, but I wasn't able to put it to run with dependency - or whatever that messages were - errors. Then I tried <a href="http://sqlfairy.sourceforge.net/">SQLFairy</a>, but does not migrate data, just the schema ddl and other cool features (worthy features).</p>

<p>I ended up doing this administrative task with <a href="http://clojure.org/">clojure</a> and <a href="http://sqlkorma.com/">korma</a>, with few functional concepts to handle the entire data set as if it was in memory.</p>

<p>The flow is: select everything from mysql, insert every thing into postgres. No transformation, no mapping, just select, insert. Take a look at the code:</p>

<p><div><script src='https://gist.github.com/2221654.js?file='></script>
<noscript><pre><code></code></pre></noscript></div>
</p>

<p>It looks more like a script than any other complex program. Korma's <code>defdb</code> and <code>defentity</code> are used to connect to databases and define its entities. Note that there are no mappings from columns or any boilerplate annotations/codes. And since the source table and destination table are equal, it is great. But what if I wanted to transform the data model? I could use the <code>transform</code> to change the shape of the data.</p>

<p>Then you see <code>fetch-every</code>. It wraps a korma select with two arguments, one for limit, one for offset. So, the query can be reused at any time.</p>

<p>Due to the volume in the scenario, I couldn't simply fetch all data and the insert all at once. I needed to paginate. But deal with pagination right in the code the is inserting and getting more data, sucks.</p>

<p>Clojure offers the excellent <a href="http://clojuredocs.org/clojure_core/clojure.core/lazy-seq"><code>lazy-seq</code></a> function and allows for creating laziness from anywhere. In this case, my lazy sequence is a sequence of pages. Although possible to have infinite ones, this sequence has an end. The end of sequence os reached right after the last row was read. See the <code>when-let</code> in the code.</p>

<p>It is what <code>extract-every</code> does. <code>extract-every</code> actually can execute any query since it is represented by a function that takes two arguments, one for limit, one for offset (<code>fech-every</code> in this case). If we call (extract-every q 20) it will limit the result in 20 rows with a offset of 0. So the head is the 20 rows representing the results, and the tail is a lazy seq of <code>etract-every</code> with a limit of 20 and a offset of 20.</p>

<p>The comes <code>persist</code>, the simples function in the code. It simply takes a v as argument and persists the data in the target database. It also prints the last tow saved for recovery purposes.</p>

<p>Wrapping up, are the <code>map</code>, or <code>pmap</code> functions. Remember that <code>map</code> applies its first argument to every entry of its second argument. So, it is simple to assemble <code>(map persist (extract-every 1500))</code>. It will save to the target database every 1500 rows or any other amount of rows.</p>

<p>It took 5 to 10 minutos to write the code and start the migration.</p>

<p>Just to play around, try:</p>

<p>``` clojure Playing lazy</p>

<pre><code>(defn until-ten 
    ([] (until-ten 0))
    ([n] (when (&lt;= n 10) (cons n (lazy-seq (until-ten (inc n)))))))
(until-ten)
</code></pre>

<p>```</p>

<p>It returns from 0 to 10, being a finite lazy sequence just like the source data set. One can use <code>take-while</code> to limit the results of a lazy-seq. You can compute really big sets using the laziness approach.</p>

<p>Hope it may be useful.</p>

<p><p>Don't forget to visit the <a href="/about">about</a> page. And follow me on Twitter: <a href="http://twitter.com/paulosuzart">@paulosuzart</a>.</p>
</p>

<p><strong>Update - Apr 7 2012</strong>: <em>Although an interesting and working solution, this code is not that functional. First of all, because it does I/O, but there is something that could be fixed to have a better "purity". <code>map</code> or <code>pmap</code> produce new sequences. Sequences full of <code>nils</code> in this case, because <code>persist</code> returns <code>nil</code>. The only advantage is the use of <code>pmap</code>, to run it in parallel, but it is still weird to have resulting seqs of <code>nils</code>.</em></p>

<p><em>A way to solve this bizarre code is using <a href="http://clojuredocs.org/clojure_core/clojure.core/doseq"><code>doseq</code></a> instead of <code>map</code> or <code>pmap</code>. It is a function that can bind each value of a <code>seq</code> and executes its body:</em></p>

<p><code>`` clojure Changing to</code>doseq`</p>

<pre><code>;;using until-ten
(doseq [i (until-ten)]
    (println "Printing " i))

;;using korma
(doseq [page (extract-every fetch-every 20)]
    (persist page))
</code></pre>

<p>```</p>

<p><em>In this case, <code>doseq</code> does not retains the head of sequences, so there is no <code>seq</code> with tons being produced.</em></p>

<p><em>Thanks to everyone around the world visiting this blog. See you!</em></p>
]]></content>
  </entry>
  
</feed>
