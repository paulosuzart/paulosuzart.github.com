<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Sliding Window events with Clojure</title>
  <meta name="description" content="Hello all, I’m back to clojure posts again. :)I was looking for a sliding window processing of events. This is something very common in the world of Complex ...">

  <!-- CSS files -->
  <link rel="stylesheet" href="http://localhost:4000/css/font-awesome.min.css">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">

  <link rel="canonical" href="http://localhost:4000/blog/2014/04/27/sliding-window-events-with-clojure/">
  <link rel="alternate" type="application/rss+xml" title="Paulo Suzart" href="http://localhost:4000/feed.xml" />

  <!-- Icons -->
  <!-- 16x16 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
  <!-- 32x32 -->
  <link rel="shortcut icon" href="http://localhost:4000/favicon.png">
</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
        

<div class="cover-card table-cell table-middle">
  
  <a href="http://localhost:4000/" class="author_name">Paulo Suzart</a>
  <span class="author_job">FP and more</span>
  <span class="author_bio mbm">back end developer | machine Learning professional wannabe</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="http://localhost:4000/">home</a>
      </li>
       
        
          <li class="nav-item">
            <a href="http://localhost:4000/archive/">Archive</a>
          </li>
        
          
        
          <li class="nav-item">
            <a href="http://localhost:4000/categories/">Categories</a>
          </li>
        
            
        
          <li class="nav-item">
            <a href="http://localhost:4000/tags/">Tags</a>
          </li>
        
             
    </ul>
  </nav>
  <script type="text/javascript">
  // based on http://stackoverflow.com/a/10300743/280842
  function gen_mail_to_link(hs, subject) {
    var lhs,rhs;
    var p = hs.split('@');
    lhs = p[0];
    rhs = p[1];
    document.write("<a class=\"social-link-item\" target=\"_blank\" href=\"mailto");
    document.write(":" + lhs + "@");
    document.write(rhs + "?subject=" + subject + "\"><i class=\"fa fa-fw fa-envelope\"></i><\/a>");
  }
</script>
<div class="social-links">
  <ul>
    
    
    
    
    <li><a href="http://linkedin.com/in/https://www.linkedin.com/in/paulosuzart/" class="social-link-item" target="_blank"><i class="fa fa-fw fa-linkedin"></i></a></li>
    
    
    
    
    <li><a href="http://github.com/github.com/paulosuzart" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <a class="btn" href= "http://localhost:4000/" >
  Home
</a>



<div id="post">
  <header class="post-header">
    <h1 title="Sliding Window events with Clojure">Sliding Window events with Clojure</h1>
    <span class="post-meta">
      <span class="post-date">
        27 APR 2014
      </span>
      •
      <span class="read-time" title="Estimated read time">
  
  
    6 mins read
  
</span>

    </span>

  </header>

  <article class="post-content">
    <p>Hello all, I’m back to <a href="http://clojuredocs.org">clojure</a> posts again. :)</p>

<p>I was looking for a sliding window processing of events. This is something very common in the world of <a href="http://en.wikipedia.org/wiki/Complex_event_processing">Complex Event Processing</a> that can be roughly translated to querying events adding a time dimension to the query.</p>

<p>We can easily find some great products/libs namely: The excelent <a href="http://www.oracle.com/technetwork/middleware/complex-event-processing/overview/complex-event-processing-088095.html">Oracle CEP</a>, <a href="http://drools.jboss.org/drools-fusion.html">Jboss Drools Fusion</a>, <a href="http://esper.codehaus.org/">Esper</a>, and the very useful <a href="http://clojurewerkz.org/">Clojure Werkz</a> <a href="https://github.com/clojurewerkz/eep">EEP, Embedded Event Processing</a>.
<!--more-->
Excepting EEP, all the others are very complete. They offer a DSL so you can query and aggregate streams of events in a very intuitive manner. But I was looking for something veeeery simple like <strong>EEP</strong>.</p>

<p>EEP comes with some basic sliding window buffers. Be it based on size, be it based on time. The point with time based windows on EEP, is that they are basically a buffer waiting for some time to be elapsed before it sends all the entries to a handler. So in this case it is not so suitable for answering questions like: <em>“How much my e-commerce sold in the last 4 minutes?”</em></p>

<p>To answer that, we can’t accumulate events for 4 minutes, send all of the to a handler, and empty the buffer. If so, two subsequential queries to the buffer will return wrong values. Ex.:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span><span class="p">|</span><span class="m">10</span> USD <span class="p">|</span><span class="m">10</span> USD , <span class="m">20</span> USD <span class="p">|</span> <span class="m">10</span> USD , <span class="m">20</span> USD                   <span class="p">|</span> <span class="m">0</span> USD
t0       t1               t3 <span class="s2">&quot;time elapsed, do empty buffer!&quot;</span>  t4</code></pre></figure>

<p>Suppose every <code>tn</code> is a minute elapsed. See? If time elapses at <code>t3</code> you <code>sum</code> and get 30, but if you want to know the  total sold one minute later, you get 0! It is not what I wanted. I then decided to go for my own implementation using <a href="https://github.com/clojurewerkz/meltdown">Meltdown</a>.</p>

<p>Meltdown is the clojure api for <a href="https://github.com/reactor/reactor">Reactor</a>, an async, message passing and stream processing lib. The concepts behind are very simple and if you tried something like <a href="http://golang.org/doc/effective_go.html#channels">Go Channels</a>, <a href="http://clojure.github.io/core.async/">core.async</a> or <a href="http://docs.paralleluniverse.co/pulsar/">Pulsar</a>, there is no mistery. Just abstract the underlaying details and go writing code.</p>

<p>Ok, enough. Lets see some code (The comments in the code explains everything):</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="c1">;; Paulo Suzart 2014</span>
<span class="c1">;; Code to suport a blog post at paulosuzart.github.io</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">melt.core</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojurewerkz.meltdown.streams</span> <span class="ss">:as</span> <span class="nv">ms</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">create</span> <span class="nv">consume</span> <span class="nv">accept</span> <span class="nv">reduce*</span><span class="p">]]</span>
            <span class="p">[</span><span class="nv">clojurewerkz.meltdown.stream-graph</span> <span class="ss">:as</span> <span class="nv">msg</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">clojurewerkz.meltdown.reactor</span> <span class="ss">:as</span> <span class="nv">mr</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">clojurewerkz.meltdown.selectors</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">$</span> <span class="nv">match-all</span><span class="p">]])</span>
  <span class="p">(</span><span class="ss">:gen-class</span><span class="p">))</span>

<span class="c1">; Holds the reactor that will receive a tick event every 1s</span>
<span class="p">(</span><span class="k">def </span><span class="nv">ticker</span> <span class="p">(</span><span class="nf">mr/create</span> <span class="ss">:event-routing-strategy</span> <span class="ss">:broadcast</span><span class="p">))</span>

<span class="c1">; Simply notifies the reactor the current time</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">tick</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nf">mr/notify</span> <span class="nv">ticker</span> <span class="s">&quot;tick&quot;</span> <span class="p">{</span><span class="ss">:time</span> <span class="p">(</span><span class="nf">System/currentTimeMillis</span><span class="p">)}))</span>

<span class="c1">; Starts to pump to `ticker` reactor</span>
<span class="p">(</span><span class="nf">future</span>
  <span class="p">(</span><span class="k">loop </span><span class="p">[]</span>
    <span class="p">(</span><span class="nf">tick</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">recur</span><span class="p">)))</span>

<span class="c1">; So far the idea is to have a global clock used to control what should</span>
<span class="c1">; be inside the sliding buffer.</span>

<span class="c1">; Cleans the buffer if the event data arrived before the current time </span>
<span class="c1">; minus the sliding interval</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">buffer-cleaner</span> <span class="p">[</span><span class="nv">buff</span> <span class="nv">interval</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">event-time</span> <span class="p">(</span><span class="nf">System/currentTimeMillis</span><span class="p">)</span>
        <span class="nv">slide</span> <span class="p">(</span><span class="nb">- </span><span class="nv">event-time</span> <span class="nv">interval</span><span class="p">)]</span>
     <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="ss">:event-time</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">slide</span><span class="p">)</span> <span class="nv">buff</span><span class="p">)))</span>

<span class="c1">; Here goes the core stuff</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">slide</span> <span class="p">[</span><span class="o">&amp;</span> <span class="nv">opts</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">options</span> <span class="p">(</span><span class="nb">apply hash-map </span><span class="nv">opts</span><span class="p">)</span>
      <span class="c1">; Channel used to dictate the steps taken</span>
      <span class="c1">; by the slide window </span>
        <span class="nv">ticker-chan</span> <span class="p">(</span><span class="ss">:ticker-chan</span> <span class="nv">options</span><span class="p">)</span> 
      <span class="c1">; Channel that actually receives events </span>
      <span class="c1">; like amount sold</span>
        <span class="nv">source-chan</span> <span class="p">(</span><span class="ss">:source-chan</span> <span class="nv">options</span><span class="p">)</span>
      <span class="c1">; Selector used to grab events from the source-chan</span>
        <span class="nv">selector</span> <span class="p">(</span><span class="ss">:selector</span> <span class="nv">options</span><span class="p">)</span>
      <span class="c1">; The window you are interested in. </span>
      <span class="c1">; Say 5 seconds. It is milisec.</span>
        <span class="nv">interval</span> <span class="p">(</span><span class="ss">:interval</span> <span class="nv">options</span><span class="p">)</span>
      <span class="c1">; In this case, the ticker will also </span>
      <span class="c1">; triggers a handler function. </span>
      <span class="c1">; For example, a function that sums up the amounts sold</span>
        <span class="nv">handler</span> <span class="p">(</span><span class="ss">:handler</span> <span class="nv">options</span><span class="p">)</span>
      <span class="c1">; The buffer holding the events being slided.</span>
        <span class="nv">buff</span> <span class="p">(</span><span class="nb">ref </span><span class="p">[])]</span>
    <span class="c1">; Invokes handler with the current buffer content</span>
    <span class="p">(</span><span class="nf">mr/on</span> <span class="nv">ticker-chan</span> <span class="p">(</span><span class="nf">$</span> <span class="s">&quot;tick&quot;</span><span class="p">)</span> 
      <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">e</span><span class="p">]</span> 
        <span class="p">(</span><span class="nf">handler</span> <span class="p">(</span><span class="nb">map </span><span class="ss">:event-data</span> <span class="o">@</span><span class="nv">buff</span><span class="p">))))</span> <span class="c1">;processes the handler</span>
    <span class="c1">; Adds a new evet data to the buffer. </span>
    <span class="p">(</span><span class="nf">mr/on</span> <span class="nv">source-chan</span> <span class="nv">selector</span> 
      <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">e</span><span class="p">]</span> 
        <span class="p">(</span><span class="nb">dosync </span>
          <span class="p">(</span><span class="nb">alter </span><span class="nv">buff</span> <span class="nb">conj </span><span class="p">{</span><span class="ss">:event-data</span> <span class="p">(</span><span class="ss">:data</span> <span class="nv">e</span><span class="p">)</span> 
                            <span class="ss">:event-time</span> <span class="p">(</span><span class="nf">System/currentTimeMillis</span><span class="p">)}))))</span>
    <span class="c1">; On the tick of the ticker, clean up old non-relevant data.</span>
    <span class="p">(</span><span class="nf">mr/on</span> <span class="nv">ticker-chan</span> <span class="p">(</span><span class="nf">$</span> <span class="s">&quot;tick&quot;</span><span class="p">)</span>
      <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="p">(</span><span class="nb">dosync </span>
                <span class="p">(</span><span class="nb">ref-set </span><span class="nv">buff</span> <span class="p">(</span><span class="nf">buffer-cleaner</span> <span class="o">@</span><span class="nv">buff</span> <span class="nv">interval</span><span class="p">)))))))</span> 

<span class="c1">; The reactor that holds </span>
<span class="p">(</span><span class="k">def </span><span class="nv">prices</span> <span class="p">(</span><span class="nf">mr/create</span><span class="p">))</span>

<span class="p">(</span><span class="nf">slide</span> <span class="ss">:ticker-chan</span> <span class="nv">ticker</span> 
       <span class="ss">:source-chan</span> <span class="nv">prices</span>
       <span class="ss">:selector</span> <span class="p">(</span><span class="nf">match-all</span><span class="p">)</span>
       <span class="ss">:interval</span> <span class="mi">5000</span>
       <span class="ss">:handler</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">b</span><span class="p">]</span> <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Last 5 seconds earnings &quot;</span> 
                  <span class="p">(</span><span class="nb">apply + </span><span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">System/currentTimeMillis</span><span class="p">))))</span>

<span class="c1">;; just for testing:</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">add-prices</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nf">mr/notify</span> <span class="nv">prices</span> <span class="s">&quot;camisa&quot;</span> <span class="mi">20</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">2000</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">mr/notify</span> <span class="nv">prices</span> <span class="s">&quot;chapa&quot;</span> <span class="mi">30</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">2000</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">mr/notify</span> <span class="nv">prices</span> <span class="s">&quot;tenis&quot;</span> <span class="mi">20</span><span class="p">)</span>
  <span class="nv">nil</span>
<span class="p">)</span></code></pre></figure>

<p>I could have embedded the ticker channel in the <code>slide</code> function. Or it could be a record implementing some protocol, etc. But this is quite simple and enough for now.</p>

<p>There is no mistery, but for sure the combination of Meltdown’s clean interface plus clojure’s ability to handle concurrency make this type of construction very straightforward.</p>

<p>Notice, however, that bigger your window interval, bigger your buffer. Faster you add events to the <code>price</code> reactor, faster your buffer becomes bigger. Seems no problem for the power of Reactor.</p>

<p>Tha is all. CEP is very useful in the filds of pattern/behavior detection and real-time analysis for detecting fraud, etc. It pays off to study and find opportunities to provide smart solutions using it.</p>

<p>Cheers!</p>


  </article>
</div>

<div class="share-buttons">
  <h6>Share on: </h6>
  <ul>
    <li>
      <a href="https://twitter.com/intent/tweet?text=http://localhost:4000/blog/2014/04/27/sliding-window-events-with-clojure/" class="twitter btn" title="Share on Twitter"><i class="fa fa-twitter"></i><span> Twitter</span></a>
    </li>
    <li>
      <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/blog/2014/04/27/sliding-window-events-with-clojure/" class="facebook btn" title="Share on Facebook"><i class="fa fa-facebook"></i><span> Facebook</span></a>
    </li>
    <li>
      <a href="https://plus.google.com/share?url=http://localhost:4000/blog/2014/04/27/sliding-window-events-with-clojure/" class="google-plus btn" title="Share on Google Plus"><i class="fa fa-google-plus"></i><span> Google+</span></a>
    </li>
    <li>
      <a href="https://news.ycombinator.com/submitlink?u=http://localhost:4000/blog/2014/04/27/sliding-window-events-with-clojure/" class="hacker-news btn" title="Share on Hacker News"><i class="fa fa-hacker-news"></i><span> Hacker News</span></a>
    </li>
    <li>
      <a href="https://www.reddit.com/submit?url=http://localhost:4000/blog/2014/04/27/sliding-window-events-with-clojure/" class="reddit btn" title="Share on Reddit"><i class="fa fa-reddit"></i><span> Reddit</span></a>
    </li>
  </ul>
</div><!-- end share-buttons -->


<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'paulosuzartblog';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>



        <footer>
  &copy; 2017 Paulo Suzart. Powered by <a href="http://jekyllrb.com/">Jekyll</a>, <a href="http://github.com/renyuanz/leonids/">leonids theme</a> made with <i class="fa fa-heart heart-icon"></i>
</footer>

      </div>
    </div>
  </div>
  <script type="text/javascript" src="http://localhost:4000/js/jquery-2.1.4.min.js"></script>
<script type="text/javascript" src="http://localhost:4000/js/main.js"></script>

<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-26676810-1', 'auto');
  ga('send', 'pageview');
</script>


</body>
</html>
